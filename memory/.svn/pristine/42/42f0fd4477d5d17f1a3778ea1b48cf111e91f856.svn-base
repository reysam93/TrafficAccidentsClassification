\chapter{Conclusiones}\label{chap:Conclusiones}
Para finalizar, en este capítulo evaluaremos las soluciones que se han llevado a cabo para cumplir los objetivos propuestos, y comentaremos algunas de las limitaciones actuales de VisualHFSM 5.0 para introducir posibles líneas de trabajos futuros.


\section{Conclusiones}
Este TFG tenía dos objetivos principales: conseguir una versión más madura y potente de VisualHFSM, centrándonos especialmente en la recuperación del GUI en tiempo de ejecución para autómatas multinivel, y poner facilidades para que la herramienta pueda ser utilizada por terceros, lo que mostraría la utlidad de esta herramienta, y nos ofrecería la posibilidad de ir mejorando aspectos en base al feedback recibido por dichos usuarios.

La conclusión general es que estos objetivos se han cumplido satisfactoriamente. Se ha conseguido una versión más robusta de la herramienta que ofrece nuevas funcionalidades muy útiles, dotándola de mayor flexibilidad y más facilidad para depurar el código, demostrando su correcto funcionamiento mediante varios ejemplos de distintos tipos. Además, se ha hecho un gran esfuerzo para la difusión y se ha mejorado toda la documentación para que el primer contacto sea lo más natural y sencillo posible, dejando una práctica preparada para que los alumnos de robótica de la URJC utilicen esta herramienta en los próximos cursos.

Como hemos basado todo el trabajo en una herramienta ya existente, el primer paso ha sido conocer todo el código y la funcionalidad que ofrece la herramienta, para poder utilizarlo de base. Además, hemos intentado reaprovechar al máximo todo el código posible, evitando duplicarlo para hacer más fácil su mantenimiento. Un claro ejemplo de esto es que la GUI en tiempo de ejecución de los componentes generados es prácticamente igual a la GUI del editor gráfico.

Centrándonos ahora en las mejoras introducidas, una de las principales mejoras ha sido la recuperación del GUI en ejecución. Esta característica es realmente útil en los procesos de depuración y se perdió al hacer que VisualHFSM soportase autómatas multinivel, y fue la motivación principal de este proyecto. Para que el aspecto de todas las GUI fuese lo más similar posible para otorgar una sensación de unidad a toda la herramienta, se adaptó el la GUI ya existente en el editor gráfico, eliminando funcionalidades y widgets no necesarios, y añadiendo otros que sí eran útiles.

La otra gran mejora de esta versión de VisualHFSM es que hemos añadido al generador de código la capacidad de generar componentes en Python. Esto le añade un gran grado de flexibilidad, aumentando el número de posibles usuarios que podrían utilizarla, dado que en el mundo de la robótica se está utilizando Python como lenguaje de programación de forma cada vez más común. Para hacer esto posible hemos modificado el generador de código, creando una nueva plantilla desde cero para los autómatas, siguiendo un modelo de programación orientada a objetos. Además, aunque no ha sido posible reutilizar el código de la GUI en tiempo de ejecución de este componente, se ha buscado también que el aspecto sea lo más similar posible a la del editor y a la de los componentes generados en C++. Esta posibilidad de generar componentes en Python no reemplaza a los componentes en C++, sino que lo complementa, siendo compatible con los dos modelos.

Además de estas dos mejoras principales, hemos realizado otras que, aunque han requerido menos esfuerzo, son igualmente útiles para mejorar la usabilidad de la herramienta y por tanto la experiencia de usuario. Dentro de estas mejoras encaja la nueva forma de navegación a través de los nuevos niveles de la jerarquía, que permite mostrar el nivel deseado haciendo click en cualquiera de los estados que pertenezcan a él dentro del \textit{Tree View}. También se han resolvido los problemas de dependencias que existían en las versiones anteriores, de forma que ahora, utilizanso la infraestructura creada al instalar JdeRobot, es posible abrir la herramienta desde cualquier fichero, de forma que no es necesario tener una carpeta con el código fuente que utilizan las distintas GUIs y ejecutarlo desde ahí para que funcione.

Otra mejora a destacar, que otorga otro mayor grado de flexibilidad, ha sido la creación de los archivos de configuración para ICE. Con las versiones anteriores, el nombre que recibía la proxy para conectarse a ICE dependía de la interfaz quese fuese a conectar, pero en ocasiones, la misma interfaz podía usar proxys con distinto nombre dependiendo de la aplicación que lanzase el servidor. Esto hacía que la conexión fallase habiendo que modificar manualmente el cfg. Ahora uno de los campos que se editan para este archivo es el nombre de esta proxy, eliminando así estos problemas y haciendo totalmente posible que el código funcione con robots reales. Además, se ha hecho de forma compatible con los proyectos obtenidos mediante versiones anteriores, dado que si no se ha determinado un nombre para la proxy, entonces sí dependerá de la interfaz que se esté utilizando.

Ahora, en relación a nuestro segundo objetivo, conseguir una herramienta que sea utilizada por terceros, también se han conseguido avances satisfactorios. Para esto, empezamos por conseguir una documentación sólida, dado que la anterior trataba de versiones demasiado antiguas, por lo que no resultaba útil. En esta documentación se explica detalladamente todos los aspectos de la herramienta, así como una descripción y sus característias generales, o los pasos que hay que realizar para instalar este componente, en caso de que quiera instalarse a parte del resto de componentes de JdeRobot. También se detalla toda la funcionalidad que ofrece y cómo utilizarla, así como de que manera hay que ejecutarla, en función de si queremos o no utilizar la GUI en ejecución. Por último, esta documentación incluye también un vídeo que muestra un componente en ejecución generado con VisualHFSM 5.0, y una explicación detallada de los pasos que hay que seguir para ejecutarlo, permitiendo así probar con un ejemplo hecho que todo funciona correctamente, y poder tomarlo como primer paso para jugar con él probando las funcionalidades que ofrece la nueva herramienta.

Además de esta documentación, ha sido importante la difusión de la herramienta. Para esto escribimos un artículo al WAV, que será publicado en la edición de este año, y, además, iremos al congreso que tiene lugar en Málaga en Junio a exponer este artículo, hablando de todas las ventajas que ofrece VisualHFSM. Esto demuestra que VisualHFSM trata un tema que realmente interesa en el mundo de la robótica y nos otorga una gran oportunidad para dar a conocer esta herramienta y todas ls ventajas que ofece, pudiendo ganar usuarios potenciales.

Por último, dentro de esta tarea de difusión, hemos introducido una práctica dentro de Teaching Robotics, una sección dentro de JdeRobot pensada para la docencia, que utiliza como plataforma VisualHFSM. Esta práctica pide realizar un comportamiento muy sencillo que puede realizarse con VisualHFSM utilizando muy pocas líneas de código, de forma que los alumnos que la realicen tendrán un primer acercamiento a la herramienta, y comprobarán las facilidades que supone para el desarrollo de comportamientos de robots.

Todas las mejoras realizadas en este TFG se centran, en el fondo, en conseguir una herramienta cómoda que pueda ser utilizada. Esto se debe a que, el hecho de que sea utilizada por terceros y resulte atractiva, es el mayor indicador de la utilidad de dicha herramienta. Además, conocer el feedback de usuario nos aporta también otros puntos de vista para saber que aspectos sería conveniente mejorar, y que aspectos resultan cómodos a la gente tal y como están, para mantenerlos así.

\section{Trabajos futuros}
Aunque VisualHFSM 5.0 es una versión mucho más madura y completa quelas anteriores, aún presenta algunos aspectos que podrían mejorarse, teniéndose en cuenta para posibles líneas de trabajo futuras.

Aunque la GUI en tiempo de ejecución supone una gran ayuda para la depuración del código, aún se le podría añadir funcionalidad para que resulte incluso más útil, y es que, a veces es conveniente saber el valor de ciertas variables, además de ver en que estado se encuentra. Por esto, una posible mejora podría ser añadir a la GUI en tiempo de ejecución un nueva espacio dentro de la ventana, utilizado para mostrar las variables y su valor que le interesen al desarrollador. Sería necesario un \textit{built-in} que el usuario pueda llamar desde el código del componente para indicar que quiere mostrar o actualizar una variable y su valor.

Una limitación que hemos comprobado al probar los componentes con drones reales, es que una vez que se empieza a ejecutar el componente generado, no hay forma de detener la ejecución, dado que si se interrumpe desde el terminal el robot no se detendrá, si no que seguirá en la última velocidad que el programa le haya mandado. Esto puede dar problemas dado que si el código no se comporta como el desarrollador espera puede hacer que el robot se choque. Por esto, sería útil incluír un botón para deter el robot e interrumpir la ejecución del componente. El problema que esto plantea es que la forma de establecer la velocidad a cero depende del tipo de robot, por lo que habría que hacer que sea el usuario quien cree esta función, que será llamada al pulsar el botón.

Por último, en esta memoria hemos comentado que una de las claras ventajas de los lenguajes de programación visual es que al ser tan naturales y legibles son especialmente útiles para la docencia. Por lo tanto, podría resultar de utilidad acercar VisualHFSM aún más a los lenguajes gráficos, dando la posibilidad de crear una serie de estados preprogramados, como por ejemplo, moverse, de forma que el usuario sólo tenga que introducir la velocidad con la que quiera que se mueva el robot, pudiendo conseguir así que niños programasen comportamientos sencillos de robots. 