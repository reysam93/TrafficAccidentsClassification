\chapter{Conclusiones}\label{chap:Conclusiones}
Para finalizar, en este capítulo evaluaremos las soluciones que se han desarrollado para alcanzar los objetivos propuestos, y comentaremos algunas posibles líneas de trabajos futuros.


\section{Conclusiones}
Este TFG pretendía conseguir una versión más madura de VisualHFSM con el fin de que pudiese ser utilizada por terceros. Con esto en mente, habíamos establecido cuatro objetivos principales:

\begin{enumerate}
\item Mejorar la usabilidad del editor gráfico de la herramienta.
\item Recuperar la GUI en tiempo de ejecución para los autómatas multinivel.
\item Añadir la posibilidad de crear componentes en Python, aumentando así la flexibilidad de la herramienta.
\item Fomentar la difusión de la herramienta para darla a conocer, facilitando así que pueda ser utilizada por terceros.
\end{enumerate}

La conclusión general es que estos objetivos se han cumplido satisfactoriamente. Se ha conseguido una versión más robusta de la herramienta que ofrece nuevas funcionalidades muy útiles, dotándola de mayor flexibilidad y más facilidad para depurar el código, demostrando su correcto funcionamiento mediante varios ejemplos de distintos tipos. Además, se ha hecho un gran esfuerzo para la difusión y se ha mejorado toda la documentación para que el primer contacto sea lo más natural y sencillo posible, dejando la práctica \textit{choca-gira} para que los alumnos de robótica de la URJC utilicen esta herramienta en los próximos cursos. \\

Como hemos basado todo el trabajo en una herramienta ya existente, el primer paso ha sido conocer todo el código y la funcionalidad que ofrecía la herramienta, para utilizarlo de base. Además, hemos intentado reaprovechar al máximo todo el código posible, evitando duplicarlo para hacer más fácil su mantenimiento. Un claro ejemplo de esto es que la GUI en tiempo de ejecución de los componentes generados es prácticamente igual a la GUI del editor gráfico. \\

Centrándonos en la mejora de la usabilidad de la herramienta y mejorar la experiencia de usuario, hemos introducido una nueva forma de navegar a través de los nuevos niveles de la jerarquía, permitiendo mostrar el nivel deseado haciendo click en cualquiera de los estados que pertenezcan a él dentro del \textit{Tree View}. También hemos resuelto los problemas de dependencias que existían en las versiones anteriores haciendo posible abrir la herramienta desde cualquier directorio, de forma que no es necesario tener una carpeta con el código fuente que utilizan las distintas GUIs y ejecutarlo desde ahí para que funcione. \\

Otra mejora del editor gráfico ha sido el aumento de flexibilidad en la creación de los archivos de configuración para ICE. Ahora permite elegir el nombre de la \textit{proxy} con el que se conectará a la interfaz ICE, permitiendo así que los componentes generados por VisualHFSM puedan conectarse a las \textit{proxys} de cualquier aplicación, haciendo posible que el código funcione cómodamente con robots reales. Además, se ha hecho de forma compatible con los proyectos obtenidos mediante versiones anteriores, dado que si no se ha determinado un nombre para la \textit{proxy}, entonces sí dependerá de la interfaz que se esté utilizando. \\

La primera mejora grande de la herramienta afecta a los componentes generados por VisualHFSM, recuperando la GUI en ejecución. Esta característica es realmente útil en los procesos de depuración y se perdió al hacer que VisualHFSM soportase autómatas multinivel. Fue la motivación inicial de este proyecto. Para que el aspecto de todas las GUI fuese lo más similar posible y otorgar una sensación de unidad a toda la herramienta, se adaptó el la GUI ya existente en el editor gráfico, eliminando funcionalidades y \textit{widgets} no necesarios, y añadiendo otros que sí eran útiles. \\

La segunda gran mejora de esta versión de VisualHFSM es que hemos añadido al generador de código la capacidad de crear componentes en Python. Esto le añade una mayor flexibilidad, aumentando el número de posibles usuarios que podrían utilizarla, dado que en el mundo de la robótica se está utilizando Python como lenguaje de programación de forma cada vez más común. Para hacer esto posible hemos modificado el generador de código, creando una nueva plantilla desde cero para los autómatas, siguiendo un modelo de programación orientada a objetos. Además, se ha buscado también que el aspecto sea lo más similar posible a la del editor y a la de los componentes generados en C++. Esta posibilidad de generar componentes en Python no reemplaza a los componentes en C++, sino que lo complementa, siendo compatibles los dos modelos. \\

En relación a la difusión de la herramienta para fomentar su uso, también hemos conseguido avances satisfactorios. Empezamos por escribir una documentación sólida en la web de JdeRobot, dado que la anterior trataba de versiones demasiado antiguas, por lo que no resultaba útil. En esta documentación se explican detalladamente todos los aspectos de la herramienta, así como una descripción y sus características generales, o los pasos que hay que realizar para instalar este componente, en caso de que quiera instalarse aparte del resto de componentes de JdeRobot. También se detalla toda la funcionalidad que ofrece y cómo utilizarla, así como de qué manera hay que ejecutarla, en función de si queremos o no utilizar la GUI en ejecución. Por último, esta documentación incluye también un vídeo que muestra un componente en ejecución generado con VisualHFSM 5.0, y una explicación detallada de los pasos que hay que seguir para ejecutarlo, permitiendo así probar con un ejemplo hecho que todo funciona correctamente, y poder tomarlo como primer paso para jugar con él probando las funcionalidades que ofrece la nueva herramienta. \\

Además de esta documentación, ha sido importante la difusión de la herramienta. Hemos escrito un artículo en el congreso científico WAF, publicado comentando todas las ventajas que ofrece VisualHFSM 5.0. Esto demuestra que VisualHFSM aborda un tema que realmente interesa en el mundo de la robótica y nos otorga una gran oportunidad para dar a conocer esta herramienta y sus ventajas, pudiendo ganar usuarios potenciales. \\

Por último, dentro de esta tarea de difusión, hemos introducido una práctica dentro del entorno docente de  JdeRobot  que utiliza como plataforma VisualHFSM. Esto permite a los alumnos que la realicen tener un primer acercamiento a los autómatas, y comprobar las facilidades que supone para el desarrollo de comportamientos de robots. \\

Para finalizar esta sección, comentar que todas las mejoras introducidas con esta versión que se han resumido en las conclusiones se traducen en un desarrollo software con más de 2500 líneas de código. Esto, sin contar el diseño de las GUIs en tiempo de ejecución, los mundos creados con Gazebo para la validación experimental, las aplicaciones creadas ni la documentación escrita. Estás son únicamente las líneas de código de la herramienta que se han añadido a las versiones ya existentes.


\section{Trabajos futuros}
Aunque VisualHFSM 5.0 es una versión mucho más madura y completa que las anteriores, aún presenta algunos aspectos que podrían mejorarse, teniéndose en cuenta para posibles líneas de trabajo futuras. \\

Aunque la GUI en tiempo de ejecución supone una gran ayuda para la depuración del código, aún se le podría añadir funcionalidad para que resulte incluso más útil. Por ejemplo, a veces es conveniente saber el valor de ciertas variables, además de ver en que estado se encuentra. Una posible mejora podría ser añadir a la GUI en tiempo de ejecución un nuevo espacio, el \textit{Data View}, utilizado para mostrar las variables y su valor que le interesen al desarrollador. Sería necesario un \textit{built-in} que el usuario pueda llamar desde el código del componente para indicar qué quiere mostrar o actualizar una variable y su valor. \\

Una limitación que hemos comprobado al probar los componentes con drones reales es que una vez que se empieza a ejecutar el componente generado, no hay forma de detener la ejecución, dado que si se interrumpe desde el terminal el robot no se detendrá, si no que seguirá en la última velocidad que el programa le haya mandado. Esto puede dar problemas, si el código no se comporta como el desarrollador espera puede hacer que el robot se choque. Por esto, sería útil incluir un \emph{botón de parada de emergencia}, para detener el robot e interrumpir la ejecución del componente. El problema que esto plantea es que la forma de establecer la velocidad a cero depende del tipo de robot, por lo que habría que hacer que sea el usuario quien cree esta función, que será llamada al pulsar el botón. \\

Por último, en esta memoria hemos comentado que una de las claras ventajas de los lenguajes de programación visual es que al ser tan naturales y legibles son especialmente útiles para la docencia. Por lo tanto, podría resultar de utilidad acercar VisualHFSM aún más a los lenguajes gráficos, dando la posibilidad de crear una serie de estados preprogramados como instrucciones gráficas. Por ejemplo, moverse, de forma que el usuario sólo tenga que introducir la velocidad con la que quiera que se mueva el robot, pudiendo conseguir así que niños programasen comportamientos sencillos de robots, acercándonos al estilo de Scratch o Blockly.